/**
 * Prerequisites (using a secrets manager is always more secure than environment variables)
 * - Define an environment variable named "HS_API_KEY", and set it to the Helpshift API key corresponding to the Helpshift instance with which you have integrated your Zendesk instance.
 * - Define an environment variable named "ZD_AUTH_STRING", and set it to the following base64-encoded, combined string value (replacing the placeholders):
 *  - <ZENDESK_USER_ID>/token:<ZENDESK_API_KEY>
 *  - Example (User ID: jdoe@acme.com | API Key: ABCDEFG_APIKEY_123456_XYZ): 
 *      - Plain: jdoe@acme.com/token:ABCDEFG_APIKEY_123456_XYZ
 *      - Encoded (Base64): amRvZUBhY21lLmNvbS90b2tlbjpBQkNERUZHX0FQSUtFWV8xMjM0NTZfWFla
 * - Define an environment variable named "ZD_DOMAIN", and set it to the targeted Zendesk domain/instance
 *  - Example (Full Zendesk URL: acme_zd_domain.zendesk.com): acme_zd_domain
 */

const HTTPS = require('https');
const { type } = require('os');
const Path = require('path');

/**
 * Environment Variables
 */
const HS_API_KEY = process.env.HS_API_KEY;
const ZD_AUTH_STRING = process.env.ZD_AUTH_STRING;
const ZD_DOMAIN = process.env.ZD_DOMAIN;

/**
 * Map Helpshift Custom Issue Field (CIF) keys to Zendesk ticket field IDs
 * - Format: <Helpshift CIF key>:<Zendesk ticket field ID>
 * - Example: 'issue_type_cif': '360035189072'
 */
const HELPSHIFT_ZENDESK_FIELD_MAPPING = {
    'issue_type': 360054392194, // EXAMPLE: This is an example value, so it can be deleted
    'sentiment': '360055402313', // EXAMPLE: This is an example value, so it can be deleted
};

/**
 * Convert the specified properties from their Helpshift field name into their corresponding Zendesk property name
 * 
 * @param {object} p_fields_to_convert A custom object containing the fields that need to be converted
 * 
 * @returns {object} The newly constructed object containing the converted Zendesk property names
 */
function convertHelpshiftFieldsToZendeskProperties(p_fields_to_convert) {
    
    if (!(p_fields_to_convert instanceof Object)) {
        throw new Error(`The specified values to update are not in the form of an object: ${p_fields_to_convert}`);
    }

    let fields_to_update_converted = {};
    let related_fields;

    if (!(HELPSHIFT_ZENDESK_FIELD_MAPPING instanceof Object)) {
        throw new Error(`The specified mappings between Helpshift and Zendesk are not in the form of a valid object: ${HELPSHIFT_ZENDESK_FIELD_MAPPING}`);
    }

    related_fields = HELPSHIFT_ZENDESK_FIELD_MAPPING;

    // Iterate over each of the source fields that were provided for updating in the target
    for (let current_field_index in p_fields_to_convert) {

        let current_field_value = p_fields_to_convert[current_field_index];
        let target_field_id = related_fields[current_field_index];

        // If the target field ID is not one of the acceptable types
        if (['number', 'string'].indexOf(typeof target_field_id) < 0) {

            console.warn(`There was no matching target field found for the source field: ${current_field_index}`);
            continue;
        }

        fields_to_update_converted[target_field_id] = current_field_value;
    }

    return fields_to_update_converted;
}

/**
 * A utility method to decode a base64-encoded string
 * 
 * @param {string} p_value_to_decode 
 * 
 * @returns {string} A non-encoded string
 */
function decodeBase64(p_value_to_decode) {

    // If the specified value is not a number or a string type
    if (['number', 'string'].indexOf(typeof p_value_to_decode) < 0) {

        throw new Error(`The value specified to decode is not a valid number or string: ${p_value_to_decode}`);
    }

    return Buffer.from(p_value_to_decode, 'base64').toString('utf8');
}

/**
 * A utility method to encode a string so that it ends up as a base64-encoded string
 * 
 * @param {string} p_value_to_encode 
 * 
 * @returns {string} A base64-encoded string
 */
function encodeBase64(p_value_to_encode) {

    // If the specified value is not a number or a string type
    if (['number', 'string'].indexOf(typeof p_value_to_encode) < 0) {

        throw new Error(`The value specified to encode is not a valid number or string: ${p_value_to_encode}`);
    }

    return Buffer.from(p_value_to_encode, 'utf8').toString('base64');
}

/**
 * Extract the event details from the Helpshift event object generated by the webhook
 * 
 * @param {object} p_event_object 
 */
function extractEventDetails(p_event_object) {

    if (p_event_object instanceof Object) {

        let event_data = p_event_object.data;

        if (event_data instanceof Object) {
            
            let event_data_updates = event_data['updates'];
            let formatted_object = {};

            formatted_object['domain'] = event_data.domain;
            formatted_object['id'] = event_data.id;

            // Copy any custom issue fields that were updated into the "fields" property of the extracted event details formatted-output object
            if (event_data_updates instanceof Object) {

                formatted_object['fields'] = event_data_updates['custom_issue_fields'];
            }
            
            return formatted_object;
        }

        throw new Error(`The "data" property of the event object was not a valid object: ${p_event_object.data}`);
    }

    else {
        throw new Error(`The provided event object was not a valid Object instance: ${p_event_object}`);
    }
}

/**
 * Utility function for flattening the field names that were retrieved from the Zendesk ticket
 * 
 * @param {object} p_fields_object 
 */
function flattenFields(p_fields_object) {

    let flattened_fields = {};

    if (p_fields_object instanceof Object) {
        
        for (let current_field_index in p_fields_object) {

            let current_field = p_fields_object[current_field_index];

            flattened_fields[current_field_index] = current_field['val'];
        }
    }

    return flattened_fields;
}

async function retrieveHSIssueByID(p_parameters) {

    let parameters = p_parameters;

    // If the parameters were not passed in in the form of an object
    if (!(parameters instanceof Object)) {

        // If the specified parameter is just a number or a string
        if ((typeof parameters === 'number') || (typeof parameters === 'string')) {
            parameters = {
                id: parameters
            };
        }

        else {
            throw new Error(`The provided parameters object was not a valid Object instance: ${parameters}`);
        }
    }

    /// Construct the encoded Basic Authorization string
    let authorization_basic_password = 'Helpshift'; // Note: This can be anything
    let authorization_basic_username = HS_API_KEY;
    let authorization_string_raw = `${authorization_basic_username}:${authorization_basic_password}`;
    let authorization_string_encoded = encodeBase64(authorization_string_raw);
    
    let domain = parameters.domain;
    let issue_id = parseInt(parameters.id);
    
    // If the domain is not a string or number value
    if (['number', 'string'].indexOf(typeof domain) < 0) {
        throw new Error(`The provided Helpshift domain is not valid: ${domain}`);
    }

    if (isNaN(issue_id)) {
        throw new Error(`The issue ID is invalid: ${issue_id}`);
    }

    let path = `/v1/${domain}/issues/${issue_id}`;
    let request_options = {
        headers: {
            'Accept': 'application/json',
            'Authorization': `Basic ${authorization_string_encoded}`,
            'Content-Type': 'application/json',
        },
        hostname: `api.helpshift.com`,
        maxRedirects: 20,
        method: 'GET',
        path: path
    };
    
    return new Promise((resolve, reject) => {

        const request = HTTPS.request(request_options, response => {
            
            let response_body_string = '';
            let status_code = response.statusCode;
            
            if ((status_code >= 200) && (status_code < 300)) {
    
                response.on('data', d => {

                    // console.log(`Received data back from: ${path}`);
                    // process.stdout.write(d);
                    response_body_string = response_body_string + Buffer.from(d).toString();
                });

                response.on('end', (j) => {

                    let response_body_object = JSON.parse(response_body_string);
                        
                    if (response_body_object instanceof Object) {
                        
                        resolve(response_body_object);
                    }

                    else {
                        resolve(response_body_string);
                    }
                });
            }

            // If the status code is at an error level
            else if (status_code >= 400) {

                // Reject the promise
                reject({
                    statusCode: status_code
                });
            }
        });

        request.on('error', error => {

            // Reject the promise with a generic error code, since the real code may be unknown
            reject({
                statusCode: 400
            });
        });

        request.end();
    });
}

async function retryFunctionCall(p_function_instance, p_retry_properties, ...additional_instance_arguments) {

    const DEFAULT_RETRY_INTERVAL = parseInt(process.env.HS_DEFAULT_RETRY_INTERVAL) || 1500; // Default to 1.5 seconds per retry
    const DEFAULT_RETRY_MAXIMUM = parseInt(process.env.HS_DEFAULT_RETRY_MAXIMUM) || 0; // Default to no retries
    
    return new Promise(async function(resolve, reject) {
        
        if (!(p_function_instance instanceof Function)) {
            throw new TypeError(`The specified function is not an instance of the Function class: ${p_function_instance}`);
        }

        if (!(p_retry_properties instanceof Object)) {

            if (typeof p_retry_properties !== 'undefined') {
                throw new TypeError(`The specified "retry" properties must be an instance the Object class: ${p_retry_properties}`);
            }

            p_retry_properties = {};
        }

        let retry_interval = parseInt(p_retry_properties.interval) || DEFAULT_RETRY_INTERVAL;
        let retry_maximum = parseInt(p_retry_properties.maximum) || DEFAULT_RETRY_MAXIMUM;
        let validation_function = p_retry_properties.validationFunction;

        let operation_result;
        let retry_flag = false;

        try {
            // Make the first call immediately
            let returned_function_value = await p_function_instance.call(undefined, ...additional_instance_arguments);
            
            // If a validation function was provided
            if (validation_function instanceof Function) {
    
                // Execute the validation function, passing in the operation result as the value to validate
                let validation_result = validation_function.call(undefined, returned_function_value);
    
                // If the value passes validation
                if (validation_result === true) {

                    resolve(returned_function_value);
                }

                // If the value does not pass validation
                else {

                    // Indicate that a retry is needed
                    retry_flag = true;
                }

                operation_result = returned_function_value;
            }
        }

        catch (e_exception) {

            // Since the operation failed, indicate that a retry is needed
            retry_flag = true;
        }

        // If a retry is needed
        if (retry_flag === true) {

            // If there is no allotment for a retry
            if (retry_maximum < 1) {

                // Reject the promise using the value returned by the operation
                reject(operation_result);
            }

            else {
                // Adjust the existing retry properties to account for the recursive call
                let adjusted_retry_properties = {
                    interval: retry_interval,
                    maximum: (retry_maximum - 1), // Reduce the maximum by one since we eventually want to reach 0 retries
                    validationFunction: validation_function
                };
                
                console.info(`The function needs to be retried. Waiting ${retry_interval}ms, and there are ${retry_maximum} attempt${(retry_maximum === 1) ? '':'s'} remaining.`);

                // Pause the control flow for the amount of time indicated by the retry interval
                setTimeout(async function() {
                    
                    try {

                        // Recursively execute the function that needs to be retried
                        let result_of_retry_execution = await retryFunctionCall.call(undefined, p_function_instance, adjusted_retry_properties, ...additional_instance_arguments);

                        resolve(result_of_retry_execution);
                    }

                    catch (exception_from_retry_execution) {

                        reject(exception_from_retry_execution);
                    }


                }, retry_interval);
            }
        }
    });
}

/**
 * Retrieve the Zendesk ticket ID from the originating Helpshift Issue by parsing the automated Zendesk private note
 * 
 * @param {object} p_parameters The object being used to intake a loose set of properties
 * 
 * @returns {string} Zendesk Ticket ID
 */
async function retrieveZDTicketIDFromHSIssue(p_parameters) {

    if (!(p_parameters instanceof Object)) {
        throw new Error(`The provided parameters object was not a valid Object instance: ${p_parameters}`);
    }

    let zendesk_ticket_id;
    
    let issue_retrieval_parameters = {
        domain: p_parameters.domain,
        id: p_parameters.id
    };

    let retry_properties = {
        
        validationFunction: function(value_to_validate) {
            
            try {
                zendesk_ticket_id = processRetrievedIssueDataForZDID(value_to_validate);

                // If the value to validate is an object
                return (typeof zendesk_ticket_id !== 'undefined');
            }

            catch (e_exception) {
                console.error(`\nThe validation function failed.`);
                console.error(e_exception);
            }
        }
    };

    let results_retrieve_issue_by_id;
    
    try {

        // Retrieve the issue by its ID (and any other specified parameters)
        results_retrieve_issue_by_id = await retryFunctionCall(retrieveHSIssueByID, retry_properties, issue_retrieval_parameters);
    }

    catch (e_exception) {

        console.error(e_exception);
    }

    // Return the successfully extracted ticket ID as the result of the executed operations
    return zendesk_ticket_id;
}

function processRetrievedIssueDataForZDID(results_retrieve_issue_by_id) {
    
    // If the response does not parse into a valid Object instance
    if (!(results_retrieve_issue_by_id instanceof Object)) {
        throw new Error(`The retrieved issue data is not a valid Object instance: ${results_retrieve_issue_by_id}`);
    }

    let num_total_hits = results_retrieve_issue_by_id['total-hits']; // The server-calculated number of total results returned

    // If there isn't exactly one issue in the response
    if (num_total_hits !== 1) {
        throw new Error(`The incorrect number of issues was returned in the response for retrieving the Helpshift issue by ID: ${num_total_hits}`);
    }

    let issues = results_retrieve_issue_by_id['issues'];

    // If the returned object has an "issues" property that is an Array instance
    if (!(issues instanceof Array)) {
        throw new Error(`The "issues" property in the response object is not a valid Array instance`);
    }

    // If less than 1 issue was returned
    if (issues.length < 1) {
        throw new Error(`Exactly one issue was expected, but there were 0 issues returned.`);
    }

    // If more than 1 issue was returned
    if (issues.length > 1) {
        throw new Error(`Exactly one issue was expected, but more than one issue was returned: ${issues.length}`);
    }

    let retrieved_issue = issues[0]; // Use the issue at the first index in the array (the only issue in the array)

    let zendesk_ticket_id = extractZDTicketIDFromHSIssueObject(retrieved_issue);

    // Return the successfully extracted ticket ID as the result of the executed operations
    return zendesk_ticket_id;
}

function extractZDTicketIDFromHSIssueObject(p_issue_object) {
    
    // If the expected issue value is not a valid Object instance
    if (!(p_issue_object instanceof Object)) {
        throw new TypeError(`The specified value to be used as an issue object is not a valid Object instance: ${p_issue_object}`);
    }
    
    let private_notes = p_issue_object['private_notes'];

    // If the "private_notes" property for the retrieved issue is not a valid Array instance
    if (!(private_notes instanceof Array)) {
        throw new Error(`The "private_notes" property of the retrieved issue is not a valid Array instance, and could mean that there are no private notes associated with the issue: ${private_notes}`);
    }

    let selected_private_note;
    let ticket_id;
    
    // Iterate over each of the private notes that are found to be part of the object, until a Zendesk ticket URL reference is found
    for (let current_note of private_notes) {
        
        // If the current private note is not a valid object
        if (!(current_note instanceof Object)) {
            console.warn(`The current private note is not a valid Object instance: ${current_note}`);
            continue; // Skip this private note value
        }

        let current_note_author = current_note['author'];

        // If the current private note does not have an "author" property that is an Object instnace
        if (!(current_note_author instanceof Object)) {
            console.warn(`The "author" property for the current private note is not a valid Object instance: ${current_note_author}`);
        }

        let current_note_author_name = `${current_note_author['name'] || ''}`.toLowerCase();

        // If the name of the author for the current private note is not the API bot's name
        // Note: Not an immediate need, but it would be more robust to go off of an immutable ID instead of the name string
        if (current_note_author_name !== 'api-bot') {
            // continue;
        }

        let current_note_body = current_note['body'];
        
        try {

            let ticket_id_raw = extractZendeskTicketIDFromText(current_note_body);

            // Set the persisting values to the current values from within the current loop iteration
            selected_private_note = current_note;
            ticket_id = ticket_id_raw;

            break; // If this point is reached without exception, then the loop can be exited
        }

        catch (e_exception) {
            continue;
        }
    }

    // If the ticket ID value is not a number or a string type
    if (['number', 'string'].indexOf(typeof ticket_id) < 0) {
        throw new Error(`No valid ticket ID value was able to be found from the specified Helpshift issue with the following ID: ${p_issue_object.id}`);
    }

    return ticket_id;
}

function extractZendeskTicketIDFromText(p_text) {

    // If the body of the current private note is not a string
    if (!(typeof p_text === 'string')) {
        console.warn(`The body of the current private note is not a valid string value: ${p_text}`);
    }
    
    let matched_urls = p_text.match(/(http|https):\/\/([\w_-]+(?:(?:\.[\w_-]+)+))([\w.,@?^=%&:\/~+#-]*[\w@?^=%&\/~+#-])?/gi);

    // If an Array instance is not produced as a result of the string RegEx match() method, this could mean either no URL match was found, or an error occurred
    if (!(matched_urls instanceof Array)) {
        throw new Error(`No match was found for: ${p_text}`); // Regardless, skip to the next private note since the current one does not have a URL to reference
    }

    // Choose the very last matched URL
    let last_matched_url_raw = matched_urls[matched_urls.length - 1];
    let last_matched_url_parsed;

    try {
        last_matched_url_parsed = new URL(last_matched_url_raw);
    }
    
    catch (e_exception) {
        console.error(`An error occurred when attempting to process the last matched URL: ${last_matched_url_raw}`);
        throw new Error(e_exception);
    }

    let url_pathname = last_matched_url_parsed.pathname;

    // If the path name of the parsed URL is not a string value
    if (!(typeof url_pathname === 'string')) {
        console.warn(`The path name of the parsed URL is not a string value: ${url_pathname}`);
    }

    let parsed_url_pathname = Path.parse(url_pathname);

    // If the parsing of the URL pathname does not result in a valid, usable Object instance
    if (!(parsed_url_pathname instanceof Object)) {
        throw new TypeError(`The parsed URL pathname did not resolve into a valid Object instnace: ${parsed_url_pathname}`);
    }

    let ticket_id_raw = parsed_url_pathname['name']; // Use the "name" property as the ID of the Zendesk ticket

    // If the raw ticket ID value is not a number or a string type
    if (['number', 'string'].indexOf(typeof ticket_id_raw) < 0) {
        throw new Error(`The "name" property of the parsed url pathname does not contain a valid number or string value, so it cannot be used as the ticket ID: ${ticket_id_raw}`);
    }

    return ticket_id_raw;
}

/**
 * Retrieve the Zendesk ticket by its external ID
 * 
 * @param {string} p_external_id 
 */
async function retrieveTicketByExternalID(p_external_id) {

    let external_id = parseInt(p_external_id);

    if (!isNaN(external_id)) {

        let request_options = {
            headers: {
                'Accept': 'application/json',
                'Authorization': `Basic ${ZD_AUTH_STRING}`,
                'Content-Type': 'application/json',
            },
            hostname: `${ZD_DOMAIN}.zendesk.com`,
            maxRedirects: 20,
            method: 'GET',
            path: `/api/v2/tickets/${external_id}`
        };
        
        return new Promise((resolve, reject) => {
    
            const request = HTTPS.request(request_options, response => {
                
                let response_body_string = '';
                let status_code = response.statusCode;
                
                if ((status_code >= 200) && (status_code < 300)) {
    
                    console.log(`statusCode: ${status_code}`);
        
                    response.on('data', d => {
                        // process.stdout.write(`An error occurred (${status_code}) while attempting to make a request to Zendesk to retrieve the ticket by its external ID.\n`);
                        // process.stdout.write(d);
                        response_body_string = response_body_string + Buffer.from(d).toString();
                    });
    
                    response.on('end', () => {
                        
                        try {
                            let response_body_object = JSON.parse(response_body_string);
                            
                            if (response_body_object instanceof Object) {
                                console.log('response_body_object');console.log(response_body_object);

                                let response_body_property_ticket = response_body_object['ticket'];
                                
                                if (response_body_property_ticket instanceof Object) {
                                        
                                    resolve(response_body_property_ticket);
                                }
                            }
                        }
    
                        catch (e_exception) {
                            console.error(e_exception);
                            throw new Error(`Encountered a problem parsing the Zendesk data`);
                        }
                    });
                }
    
                // If the status code is at an error level
                else if (status_code >= 400) {
    
                    // Reject the promise
                    reject({
                        statusCode: status_code
                    });
                }
            });
    
            request.on('error', error => {
    
                // Reject the promise with a generic error code, since the real code may be unknown
                reject({
                    statusCode: 400
                });
            });

            request.end();
        });
    }
}

/**
 * Updates each specified Zendesk ticket field
 * @param {string} p_ticket_id 
 * @param {object} p_fields_to_update 
 */
async function updateTicketFields(p_ticket_id, p_fields_to_update) {

    let ticket_id = parseInt(p_ticket_id);

    if (isNaN(ticket_id)) {
        throw new Error(`The ticket ID is invalid: ${p_ticket_id}`);
    }

    let fields_to_update_converted = convertHelpshiftFieldsToZendeskProperties(p_fields_to_update);

    if (fields_to_update_converted instanceof Object) {

        let request_options = {
            headers: {
                'Accept': 'application/json',
                'Authorization': `Basic ${ZD_AUTH_STRING}`,
                'Content-Type': 'application/json',
            },
            hostname: `${ZD_DOMAIN}.zendesk.com`,
            maxRedirects: 20,
            method: 'PUT',
            path: `/api/v2/tickets/${ticket_id}`
        };
        
        let payload = {
            'ticket': {
                'fields': []
            }
        };
        
        for (let current_field_index in fields_to_update_converted) {

            let current_field_value = fields_to_update_converted[current_field_index];

            payload['ticket']['fields'].push({
                id: current_field_index,
                value: current_field_value
            });
        }
        
        let payload_stringified = JSON.stringify(payload);
        
        return new Promise((resolve, reject) => {
    
            const request = HTTPS.request(request_options, response => {
                
                let response_body_string = '';
                let status_code = response.statusCode;
                
                if ((status_code >= 200) && (status_code < 300)) {
        
                    response.on('data', d => {
                        // process.stdout.write(`An error occurred while attempting to make a request to Zendesk to retrieve the ticket by its external ID.\n`);
                        // process.stdout.write(d);
                        response_body_string = response_body_string + Buffer.from(d).toString();
                    });
    
                    response.on('end', () => {
    
                        try {
                            let response_body_object = JSON.parse(response_body_string);
                            
                            if (response_body_object instanceof Object) {
                                
                                resolve(true);
                            }
                        }
    
                        catch (e_exception) {
                            console.error(e_exception);
                            throw new Error(`Encountered a problem parsing the Zendesk data`);
                        }
                    });
                }
    
                // If the status code is at an error level
                else if (status_code >= 400) {
    
                    // Reject the promise
                    reject({
                        statusCode: status_code
                    });
                }
            });
    
            request.on('error', error => {
    
                // Reject the promise with a generic error code, since the real code may be unknown
                reject({
                    statusCode: 400
                });
            });
    
            request.write(payload_stringified);
            request.end();
        });
    }
}

exports.handler = async (event) => {
    
    let status_code = 400;
    let event_body = event.body || {};
    
    // Make sure the body value is parsed as into a JSON object
    if (!(event_body instanceof Object)) { event_body = JSON.parse(event_body); }

    try {

        // Extract event details
        let event_details = extractEventDetails(event_body);

        // Retrieve the Zendesk ticket ID by way of the Helpshift Issue ID
        let zendesk_ticket_id = await retrieveZDTicketIDFromHSIssue({domain: event_details.domain, id: event_details.id});
        
        // Retrieve ticket by external ID
        let retrieved_ticket = await retrieveTicketByExternalID(zendesk_ticket_id);

        // Flatten the field names from Helpshift so that they can be passed into Zendesk
        let fields_to_change_flattened = flattenFields(event_details.fields);
        
        // Update the corresponding ticket details in Zendesk
        let result_update_ticket_fields = await updateTicketFields(retrieved_ticket.id, fields_to_change_flattened);

        // If the result of the update to the ticket's fields is TRUE (successful)
        if (result_update_ticket_fields === true) {
            status_code = 200;
        }
        
        // TODO implement
        const response = {
            statusCode: status_code,
            body: JSON.stringify(fields_to_change_flattened),
        };
        
        return response;
    }

    catch (e_exception) {

        console.error(e_exception);

        throw e_exception;
    }
};


/********************/
/*    TEST AREA     */
/********************/

async function runTest() {
    
    // Sample fields for testing (corresponding to the sample fields above)
    let fields_to_change = {
        issue_type: {
            type: 'dropdown', val: 'Fraud'
        },
        sentiment: {
            type: 'text', val: 'NEGATIVE'
        }
    };

    let sample_hs_domain = `DEMO_HELPSHIFT_INSTANCE`; // TODO: Replace this with the valid name of the Helpshift instance being used for testing
    let sample_hs_issue_id = 7511; // TODO: Replace this with a valid issue ID from the Helpshift instance being used for testing

    // Retrieve the Zendesk ticket ID by way of the Helpshift Issue ID
    let retrieved_zendesk_ticket_id = await retrieveZDTicketIDFromHSIssue({
        domain: sample_hs_domain,
        id: sample_hs_issue_id
    });
    
    // Retrieve ticket by external ID
    let retrieved_zendesk_ticket = await retrieveTicketByExternalID(retrieved_zendesk_ticket_id);

    // Flatten the field names from Helpshift so that they can be passed into Zendesk
    let fields_to_change_flattened = flattenFields(fields_to_change);
    
    // Update the corresponding ticket details in Zendesk
    let result_update_ticket_fields = await updateTicketFields(retrieved_zendesk_ticket.id, fields_to_change_flattened);

    // Output the result to the console for testing
    console.log('result_update_ticket_fields');
    console.log(result_update_ticket_fields);
}

if (typeof process.env.LAMBDA_TASK_ROOT === 'undefined') {

    runTest()
    .catch(e_exception => {

        console.error('A problem occurred...');
        console.error(e_exception)
    });
}